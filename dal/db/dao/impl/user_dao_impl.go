// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.
// Code generated by jasonlabz/gentol. DO NOT EDIT.

package impl

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"github.com/jasonlabz/generate-example-project/dal/db/dao"
	"github.com/jasonlabz/generate-example-project/dal/db/model"
)

var userDao dao.UserDao = &userDaoImpl{}

func GetUserDao() dao.UserDao {
	return userDao
}

type userDaoImpl struct{}

func (u userDaoImpl) tx(ctx context.Context) *gorm.DB {
	tx, ok := ctx.Value("transactionDB").(*gorm.DB)
	if ok {
		return tx
	}
	return dao.DB()
}

func (u userDaoImpl) SelectByRawSQL(ctx context.Context, rawSQL string, result any) (err error) {
	err = u.tx(ctx).WithContext(ctx).
		Raw(rawSQL).Scan(result).Error
	return
}

func (u userDaoImpl) SelectAll(ctx context.Context, selectFields ...model.UserField) (records []*model.User, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{})
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}
	err = tx.Find(&records).Error
	return
}

func (u userDaoImpl) SelectOneByPrimaryKey(ctx context.Context, userID int64, selectFields ...model.UserField) (record *model.User, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{})
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}
	whereCondition := map[string]any{
		"user_id": userID,
	}
	err = tx.Where(whereCondition).First(&record).Error
	return
}

func (u userDaoImpl) SelectRecordByCondition(ctx context.Context, condition *model.Condition, selectFields ...model.UserField) (records []*model.User, err error) {
	if condition == nil {
		return u.SelectAll(ctx, selectFields...)
	}
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{})
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}
	if len(condition.StringCondition) > 0 {
		paramIndex := 0
		for _, strCondition := range condition.StringCondition {
			paramCount := strings.Count(strCondition, "?")
			var args []interface{}
			if paramIndex+paramCount <= len(condition.Args) {
				args = condition.Args[paramIndex : paramIndex+paramCount]
				paramIndex += paramCount
			}
			tx = tx.Where(strCondition, args...)
		}
	}
	if len(condition.MapCondition) > 0 {
		tx = tx.Where(condition.MapCondition)
	}
	for i, join := range condition.JoinCondition {
		if i < len(condition.JoinArgs) {
			tx = tx.Joins(join, condition.JoinArgs[i])
		} else {
			tx = tx.Joins(join)
		}
	}
	if condition.GroupByClause != "" {
		tx = tx.Group(condition.GroupByClause)
	}
	if condition.HavingCondition != "" {
		tx = tx.Having(condition.HavingCondition, condition.HavingArgs...)
	}
	for _, order := range condition.OrderByClause {
		tx = tx.Order(order)
	}
	err = tx.Find(&records).Error
	return
}

func (u userDaoImpl) SelectPageRecordByCondition(ctx context.Context, condition *model.Condition, pageParam *model.Pagination,
	selectFields ...model.UserField) (records []*model.User, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{})
	if len(selectFields) > 0 {
		columns := make([]string, 0)
		for _, field := range selectFields {
			columns = append(columns, string(field))
		}
		tx = tx.Select(strings.Join(columns, ","))
	}
	if condition != nil {
		if len(condition.StringCondition) > 0 {
			paramIndex := 0
			for _, strCondition := range condition.StringCondition {
				paramCount := strings.Count(strCondition, "?")
				var args []interface{}
				if paramIndex+paramCount <= len(condition.Args) {
					args = condition.Args[paramIndex : paramIndex+paramCount]
					paramIndex += paramCount
				}
				tx = tx.Where(strCondition, args...)
			}
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
		for _, order := range condition.OrderByClause {
			tx = tx.Order(order)
		}
	}
	var count int64
	if pageParam != nil {
		tx = tx.Count(&count).Offset(int(pageParam.CalculateOffset())).Limit(int(pageParam.PageSize))
	}
	err = tx.Find(&records).Error
	if pageParam != nil {
		pageParam.Total = count
		pageParam.CalculatePageCount()
	}
	return
}

func (u userDaoImpl) CountByCondition(ctx context.Context, condition *model.Condition) (count int64, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{})
	if condition != nil {
		if len(condition.StringCondition) > 0 {
			paramIndex := 0
			for _, strCondition := range condition.StringCondition {
				paramCount := strings.Count(strCondition, "?")
				var args []interface{}
				if paramIndex+paramCount <= len(condition.Args) {
					args = condition.Args[paramIndex : paramIndex+paramCount]
					paramIndex += paramCount
				}
				tx = tx.Where(strCondition, args...)
			}
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
	}
	err = tx.Count(&count).Error
	return
}

func (u userDaoImpl) DeleteByCondition(ctx context.Context, condition *model.Condition) (affect int64, err error) {
	tx := u.tx(ctx).WithContext(ctx)
	if condition != nil {
		if len(condition.StringCondition) > 0 {
			paramIndex := 0
			for _, strCondition := range condition.StringCondition {
				paramCount := strings.Count(strCondition, "?")
				var args []interface{}
				if paramIndex+paramCount <= len(condition.Args) {
					args = condition.Args[paramIndex : paramIndex+paramCount]
					paramIndex += paramCount
				}
				tx = tx.Where(strCondition, args...)
			}
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
	}
	tx = tx.Delete(&model.User{})
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) DeleteByPrimaryKey(ctx context.Context, userID int64) (affect int64, err error) {
	whereCondition := map[string]any{
		"user_id": userID,
	}
	tx := u.tx(ctx).WithContext(ctx).Where(whereCondition).Delete(&model.User{})
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) UpsertRecord(ctx context.Context, record *model.User) (affect int64, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Save(record)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) UpsertRecords(ctx context.Context, records []*model.User) (affect int64, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Save(records)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) UpdateByCondition(ctx context.Context, condition *model.Condition, updateField model.UpdateField) (affect int64, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{})
	if condition != nil {
		if len(condition.StringCondition) > 0 {
			paramIndex := 0
			for _, strCondition := range condition.StringCondition {
				paramCount := strings.Count(strCondition, "?")
				var args []interface{}
				if paramIndex+paramCount <= len(condition.Args) {
					args = condition.Args[paramIndex : paramIndex+paramCount]
					paramIndex += paramCount
				}
				tx = tx.Where(strCondition, args...)
			}
		}
		if len(condition.MapCondition) > 0 {
			tx = tx.Where(condition.MapCondition)
		}
	}
	tx = tx.Updates(map[string]any(updateField))
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) UpdateByPrimaryKey(ctx context.Context, userID int64, updateField model.UpdateField) (affect int64, err error) {
	whereCondition := map[string]any{
		"user_id": userID,
	}
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{}).
		Where(whereCondition)
	tx = tx.Updates(map[string]any(updateField))
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) Insert(ctx context.Context, record *model.User) (affect int64, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{}).
		Create(&record)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) BatchInsert(ctx context.Context, records []*model.User) (affect int64, err error) {
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{}).
		Create(&records)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) InsertOrUpdateOnDuplicateKey(ctx context.Context, record *model.User,
	uniqueKeys ...model.UserField) (affect int64, err error) {
	columns := make([]clause.Column, 0)
	for _, field := range uniqueKeys {
		columns = append(columns, clause.Column{
			Name: string(field),
		})
	}
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{}).
		Clauses(clause.OnConflict{
			Columns:   columns,
			UpdateAll: true,
		}).Create(&record)
	affect = tx.RowsAffected
	err = tx.Error
	return
}

func (u userDaoImpl) BatchInsertOrUpdateOnDuplicateKey(ctx context.Context, records []*model.User,
	uniqueKeys ...model.UserField) (affect int64, err error) {
	columns := make([]clause.Column, 0)
	for _, field := range uniqueKeys {
		columns = append(columns, clause.Column{
			Name: string(field),
		})
	}
	tx := u.tx(ctx).WithContext(ctx).
		Model(&model.User{}).
		Clauses(clause.OnConflict{
			Columns:   columns,
			UpdateAll: true,
		}).Create(&records)
	affect = tx.RowsAffected
	err = tx.Error
	return
}
